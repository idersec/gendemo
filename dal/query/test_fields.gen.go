// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"gendemo/dal/model"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"
)

func newTestField(db *gorm.DB) testField {
	_testField := testField{}

	_testField.testFieldDo.UseDB(db)
	_testField.testFieldDo.UseModel(&model.TestField{})

	tableName := _testField.testFieldDo.TableName()
	_testField.ALL = field.NewField(tableName, "*")
	_testField.TestInt = field.NewInt(tableName, "test_int")
	_testField.TestInt8 = field.NewInt8(tableName, "test_int8")
	_testField.TestInt16 = field.NewInt16(tableName, "test_int16")
	_testField.TestInt32 = field.NewInt32(tableName, "test_int32")
	_testField.TestInt64 = field.NewInt64(tableName, "test_int64")
	_testField.TestUint = field.NewUint(tableName, "test_uint")
	_testField.TestUint8 = field.NewUint8(tableName, "test_uint8")
	_testField.TestUint16 = field.NewUint16(tableName, "test_uint16")
	_testField.TestUint32 = field.NewUint32(tableName, "test_uint32")
	_testField.TestUint64 = field.NewUint64(tableName, "test_uint64")
	_testField.TestString = field.NewString(tableName, "test_string")
	_testField.TestByte = field.NewUint8(tableName, "test_byte")
	_testField.TestFloat32 = field.NewFloat32(tableName, "test_float32")
	_testField.TestFloat64 = field.NewFloat64(tableName, "test_float64")
	_testField.TestBool = field.NewTime(tableName, "test_bool")
	_testField.TestStringPoint = field.NewString(tableName, "test_string_point")
	_testField.TestIntPoint = field.NewInt(tableName, "test_int_point")

	return _testField
}

type testField struct {
	testFieldDo testFieldDo

	ALL             field.Field
	TestInt         field.Int
	TestInt8        field.Int8
	TestInt16       field.Int16
	TestInt32       field.Int32
	TestInt64       field.Int64
	TestUint        field.Uint
	TestUint8       field.Uint8
	TestUint16      field.Uint16
	TestUint32      field.Uint32
	TestUint64      field.Uint64
	TestString      field.String
	TestByte        field.Uint8
	TestFloat32     field.Float32
	TestFloat64     field.Float64
	TestBool        field.Time
	TestStringPoint field.String
	TestIntPoint    field.Int
}

func (t *testField) WithContext(ctx context.Context) *testFieldDo {
	return t.testFieldDo.WithContext(ctx)
}

func (t testField) TableName() string { return t.testFieldDo.TableName() }

func (t testField) clone(db *gorm.DB) testField {
	t.testFieldDo.ReplaceDB(db)
	return t
}

type testFieldDo struct{ gen.DO }

func (t testFieldDo) Debug() *testFieldDo {
	return t.withDO(t.DO.Debug())
}

func (t testFieldDo) WithContext(ctx context.Context) *testFieldDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t testFieldDo) Clauses(conds ...clause.Expression) *testFieldDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t testFieldDo) Not(conds ...gen.Condition) *testFieldDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t testFieldDo) Or(conds ...gen.Condition) *testFieldDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t testFieldDo) Select(conds ...field.Expr) *testFieldDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t testFieldDo) Where(conds ...gen.Condition) *testFieldDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t testFieldDo) Order(conds ...field.Expr) *testFieldDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t testFieldDo) Distinct(cols ...field.Expr) *testFieldDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t testFieldDo) Omit(cols ...field.Expr) *testFieldDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t testFieldDo) Join(table schema.Tabler, on ...field.Expr) *testFieldDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t testFieldDo) LeftJoin(table schema.Tabler, on ...field.Expr) *testFieldDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t testFieldDo) RightJoin(table schema.Tabler, on ...field.Expr) *testFieldDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t testFieldDo) Group(cols ...field.Expr) *testFieldDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t testFieldDo) Having(conds ...gen.Condition) *testFieldDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t testFieldDo) Limit(limit int) *testFieldDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t testFieldDo) Offset(offset int) *testFieldDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t testFieldDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *testFieldDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t testFieldDo) Unscoped() *testFieldDo {
	return t.withDO(t.DO.Unscoped())
}

func (t testFieldDo) Create(values ...*model.TestField) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t testFieldDo) CreateInBatches(values []*model.TestField, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t testFieldDo) Save(values ...*model.TestField) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t testFieldDo) First() (*model.TestField, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TestField), nil
	}
}

func (t testFieldDo) Take() (*model.TestField, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TestField), nil
	}
}

func (t testFieldDo) Last() (*model.TestField, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TestField), nil
	}
}

func (t testFieldDo) Find() ([]*model.TestField, error) {
	result, err := t.DO.Find()
	return result.([]*model.TestField), err
}

func (t testFieldDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) ([]*model.TestField, error) {
	result, err := t.DO.FindInBatch(batchSize, fc)
	return result.([]*model.TestField), err
}

func (t testFieldDo) FindInBatches(result []*model.TestField, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(&result, batchSize, fc)
}

func (t testFieldDo) Attrs(attrs ...field.AssignExpr) *testFieldDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t testFieldDo) Assign(attrs ...field.AssignExpr) *testFieldDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t testFieldDo) Joins(field field.RelationField) *testFieldDo {
	return t.withDO(t.DO.Joins(field))
}

func (t testFieldDo) Preload(field field.RelationField) *testFieldDo {
	return t.withDO(t.DO.Preload(field))
}

func (t testFieldDo) FirstOrInit() (*model.TestField, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TestField), nil
	}
}

func (t testFieldDo) FirstOrCreate() (*model.TestField, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TestField), nil
	}
}

func (t testFieldDo) FindByPage(offset int, limit int) (result []*model.TestField, count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	result, err = t.Offset(offset).Limit(limit).Find()
	return
}

func (t *testFieldDo) withDO(do gen.Dao) *testFieldDo {
	t.DO = *do.(*gen.DO)
	return t
}
